<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Getting Started | Illumination Engine A Game Development Engine Written In C++</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="IlluminationEngineLogo128.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m"><img src="IlluminationEngineLogo128.png" alt="" />Illumination Engine <span class="m-thin">A Game Development Engine Written In C++</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="https://joellogan.github.io">Main Page</a></li>
            <li><a href="pages.html">Pages</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Getting Started
        </h1>
<p><code>vk-bootstrap</code> reduces the complexity of setting up a vulkan application by simplifying the three initial steps; instance creation, Physical device selection, and device creation.</p><section id="autotoc_md1"><h2><a href="#autotoc_md1">Instance Creation</a></h2><p>Creating an instance with <code>vk-bootstrap</code> uses the <code><a href="classvkb_1_1_instance_builder.html" class="m-doc">vkb::<wbr />InstanceBuilder</a></code> class.</p><p>Simply create a builder variable and call the <code>build()</code> member function.</p><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">InstanceBuilder</span> <span class="n">instance_builder</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">instance_builder_return</span> <span class="o">=</span> <span class="n">instance_builder</span><span class="p">.</span><span class="n">build</span><span class="p">();</span></pre><p>Because creating an instance may fail, the builder returns an &#x27;Result&#x27; type. This contains either a valid <code><a href="structvkb_1_1_instance.html" class="m-doc">vkb::<wbr />Instance</a></code> struct, which includes a <code>VkInstance</code> handle, or contains an <code><a href="namespacevkb.html#a0189237d690fabbecc498244689947d8" class="m-doc">vkb::<wbr />InstanceError</a></code>.</p><pre class="m-code"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance_builder_return</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Failed to create Vulkan instance. Error: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">instance_builder_return</span><span class="p">.</span><span class="n">error</span><span class="p">().</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></pre><p>Once any possible errors have been dealt with, we can pull the <code><a href="structvkb_1_1_instance.html" class="m-doc">vkb::<wbr />Instance</a></code> struct out of the <code>Result</code>. <code class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">Instance</span> <span class="n">vkb_instance</span> <span class="o">=</span> <span class="n">instance_builder_return</span><span class="p">.</span><span class="n">value</span><span class="p">();</span></code> This is enough to create a usable <code>VkInstance</code> handle but many will want to customize it a bit. To configure instance creation, simply call the member functions on the <code><a href="classvkb_1_1_instance_builder.html" class="m-doc">vkb::<wbr />InstanceBuilder</a></code> object before <code>build()</code> is called.</p><p>The most common customization to instance creation is enabling the &quot;Validation Layers&quot;, an invaluable tool for any vulkan application developer. <code class="m-code"><span class="n">instance_builder</span><span class="p">.</span><span class="n">request_validation_layers</span> <span class="p">();</span></code> The other common customization point is setting up the <code>Debug Messenger Callback</code>, the mechanism in which an application can control what and where the &quot;Validation Layers&quot; log its output.</p><pre class="m-code"><span class="n">instance_builder</span><span class="p">.</span><span class="n">set_debug_callback</span> <span class="p">(</span>
    <span class="p">[]</span> <span class="p">(</span><span class="n">VkDebugUtilsMessageSeverityFlagBitsEXT</span> <span class="n">messageSeverity</span><span class="p">,</span>
        <span class="n">VkDebugUtilsMessageTypeFlagsEXT</span> <span class="n">messageType</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">VkDebugUtilsMessengerCallbackDataEXT</span><span class="o">*</span> <span class="n">pCallbackData</span><span class="p">,</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">pUserData</span><span class="p">)</span> 
        <span class="o">-&gt;</span> <span class="n">VkBool32</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">severity</span> <span class="o">=</span> <span class="n">vkb</span><span class="o">::</span><span class="n">to_string_message_severity</span> <span class="p">(</span><span class="n">messageSeverity</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">type</span> <span class="o">=</span> <span class="n">vkb</span><span class="o">::</span><span class="n">to_string_message_type</span> <span class="p">(</span><span class="n">messageType</span><span class="p">);</span>
            <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;[%s: %s] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">severity</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">pCallbackData</span><span class="o">-&gt;</span><span class="n">pMessage</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">VK_FALSE</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">);</span></pre><p>Alternatively, <code>vk-bootstrap</code> provides a &#x27;default debug messenger&#x27; that prints to standard output. <code class="m-code"><span class="n">instance_builder</span><span class="p">.</span><span class="n">use_default_debug_messenger</span><span class="p">();</span></code> Configuration can be chained together and done inline with building, like so.</p><pre class="m-code"><span class="k">auto</span> <span class="n">inst_builder_ret</span> <span class="o">=</span> <span class="n">instance_builder</span> 
        <span class="p">.</span><span class="n">set_app_name</span> <span class="p">(</span><span class="s">&quot;Awesome Vulkan Application&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">set_engine_name</span><span class="p">(</span><span class="s">&quot;Excellent Game Engine&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">require_api_version</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">.</span><span class="n">build</span><span class="p">();</span></pre><p>To query the available layers and extensions, get a <code>SystemInfo</code> struct from <code>SystemInfo::get_system_info()</code>. It contains a <code>is_layer_available()</code> and <code>is_extension_available()</code> function to check for a layer or extensions before enabling it. It also has booleans for if the validation layers are present and if the VK_EXT_debug_utils extension is available.</p><pre class="m-code"><span class="k">auto</span> <span class="n">system_info_ret</span> <span class="o">=</span> <span class="n">vkb</span><span class="o">::</span><span class="n">SystemInfo</span><span class="p">.</span><span class="n">get_system_info</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system_info_ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">system_info_ret</span><span class="p">.</span><span class="n">error</span><span class="p">().</span><span class="n">message</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">auto</span> <span class="n">system_info</span> <span class="o">=</span> <span class="n">system_info_ret</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">system_info</span><span class="p">.</span><span class="n">is_layer_available</span><span class="p">(</span><span class="s">&quot;VK_LAYER_LUNARG_api_dump&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">instance_builder</span><span class="p">.</span><span class="n">enable_layer</span><span class="p">(</span><span class="s">&quot;VK_LAYER_LUNARG_api_dump&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">system_info</span><span class="p">.</span><span class="n">validation_layers_available</span><span class="p">){</span>
    <span class="n">instance_builder</span><span class="p">.</span><span class="n">enable_validation_layers</span><span class="p">();</span>
<span class="p">}</span></pre><p>The <code><a href="structvkb_1_1_instance.html" class="m-doc">vkb::<wbr />Instance</a></code> struct is meant to hold all the necessary instance level data to enable proper Physical Device selection. It also is meant for easy destructuring into custom classes if so desired.</p><pre class="m-code"><span class="k">struct</span> <span class="n">CustomVulkanWrapper</span> <span class="p">{</span>
    <span class="n">VkInstance</span> <span class="n">instance</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
<span class="n">CustomVulkanWrapper</span> <span class="n">custom_vk_class</span><span class="p">;</span>
<span class="n">custom_vk_class</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">vkb_instance</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span></pre><p>When the application is finished with the vulkan, call <code><a href="namespacevkb.html#acc7b3ebee8d1f031cebc223067276e88" class="m-doc">vkb::<wbr />destroy_instance()</a></code> to dispose of the instance and associated data.</p><pre class="m-code"><span class="c1">// cleanup </span>
<span class="n">vkb</span><span class="o">::</span><span class="n">destroy_instance</span><span class="p">(</span><span class="n">vkb_instance</span><span class="p">);</span></pre><section id="autotoc_md2"><h3><a href="#autotoc_md2">Instance Creation Summary</a></h3><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">InstanceBuilder</span> <span class="n">instance_builder</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">instance_builder_return</span> <span class="o">=</span> <span class="n">instance_builder</span>
        <span class="c1">// Instance creation configuration</span>
        <span class="p">.</span><span class="n">request_validation_layers</span><span class="p">()</span>
        <span class="p">.</span><span class="n">use_default_debug_messenger</span><span class="p">()</span>
        <span class="p">.</span><span class="n">build</span> <span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance_builder_return</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle error</span>
<span class="p">}</span> 
<span class="n">vkb</span><span class="o">::</span><span class="n">Instance</span> <span class="n">vkb_instance</span> <span class="o">=</span> <span class="n">instance_builder_return</span><span class="p">.</span><span class="n">value</span> <span class="p">();</span>

<span class="c1">// at program end</span>
<span class="n">vkb</span><span class="o">::</span><span class="n">destroy_instance</span><span class="p">(</span><span class="n">vkb_instance</span><span class="p">);</span></pre></section></section><section id="autotoc_md3"><h2><a href="#autotoc_md3">Surface Creation</a></h2><p>Presenting images to the screen Vulkan requires creating a surface, encapsulated in a <code>VkSurfaceKHR</code> handle. Creating a surface is the responsibility of the windowing system, thus is out of scope for <code>vk-bootstrap</code>. However, <code>vk-bootstrap</code> does try to make the process as painless as possible by automatically enabling the correct windowing extensions in <code>VkInstance</code> creation.</p><p>Windowing libraries which support Vulkan usually provide a way of getting the <code>VkSurfaceKHR</code> handle for the window. These methods require a valid Vulkan instance, thus must be done after instance creation.</p><p>Examples for GLFW and SDL2 are listed below.</p><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">Instance</span> <span class="n">vkb_instance</span><span class="p">;</span> <span class="c1">//valid vkb::Instance</span>
<span class="n">VkSurfaceKHR</span> <span class="n">surface</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="c1">// window is a valid library specific Window handle</span>

<span class="c1">// GLFW</span>
<span class="n">VkResult</span> <span class="n">err</span> <span class="o">=</span> <span class="n">glfwCreateWindowSurface</span> <span class="p">(</span><span class="n">vkb_instance</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surface</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">VK_SUCCESS</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* handle error */</span> <span class="p">}</span>

<span class="c1">// SDL2</span>
<span class="n">SDL_bool</span> <span class="n">err</span> <span class="o">=</span> <span class="n">SDL_Vulkan_CreateSurface</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">vkb_instance</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surface</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">){</span> <span class="cm">/* handle error */</span> <span class="p">}</span></pre></section><section id="autotoc_md4"><h2><a href="#autotoc_md4">Physical Device Selection</a></h2><p>Once a Vulkan instance has been created, the next step is to find a suitable GPU for the application to use. <code>vk-bootstrap</code> provide the <code><a href="classvkb_1_1_physical_device_selector.html" class="m-doc">vkb::<wbr />PhysicalDeviceSelector</a></code> class to streamline this process.</p><p>Creating a <code><a href="classvkb_1_1_physical_device_selector.html" class="m-doc">vkb::<wbr />PhysicalDeviceSelector</a></code> requires a valid <code><a href="structvkb_1_1_instance.html" class="m-doc">vkb::<wbr />Instance</a></code> to construct.</p><p>It follows the same pattern laid out by <code><a href="classvkb_1_1_instance_builder.html" class="m-doc">vkb::<wbr />InstanceBuilder</a></code>.</p><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">PhysicalDeviceSelector</span> <span class="n">phys_device_selector</span> <span class="p">(</span><span class="n">vkb_instance</span><span class="p">);</span> 
<span class="k">auto</span> <span class="n">physical_device_selector_return</span> <span class="o">=</span> <span class="n">phys_device_selector</span>
        <span class="p">.</span><span class="n">set_surface</span><span class="p">(</span><span class="n">surface_handle</span><span class="p">)</span>
        <span class="p">.</span><span class="n">select</span> <span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">physical_device_selector_return</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle error</span>
<span class="p">}</span>
<span class="k">auto</span> <span class="n">phys_device</span> <span class="o">=</span> <span class="n">phys_device_ret</span><span class="p">.</span><span class="n">value</span> <span class="p">();</span></pre><p>To select a physical device, call <code>select()</code> on the <code><a href="classvkb_1_1_physical_device_selector.html" class="m-doc">vkb::<wbr />PhysicalDeviceSelector</a></code> object. By default, this will prefer a discrete GPU.</p><p>No cleanup is required for <code><a href="structvkb_1_1_physical_device.html" class="m-doc">vkb::<wbr />PhysicalDevice</a></code>.</p><p>The <code><a href="classvkb_1_1_physical_device_selector.html" class="m-doc">vkb::<wbr />PhysicalDeviceSelector</a></code> will look for the first device in the list that satisfied all the specified criteria, and if none is found, will return the first device that partially satisfies the criteria.</p><p>The various &quot;require&quot; and &quot;desire&quot; pairs of functions indicate to <code>vk-bootstrap</code> what features and capabilities are necessary for an application and what are simply preferred. A &quot;require&quot; function will fail any <code>VkPhysicalDevice</code> that doesn&#x27;t satisfy the constraint, while any criteria that doesn&#x27;t satisfy the &quot;desire&quot; functions will make the <code>VkPhysicalDevice</code> only &#x27;partially satisfy&#x27;.</p><pre class="m-code"><span class="c1">// Application cannot function without this extension</span>
<span class="n">phys_device_selector</span><span class="p">.</span><span class="n">add_required_extension</span><span class="p">(</span><span class="s">&quot;VK_KHR_timeline_semaphore&quot;</span><span class="p">);</span>

<span class="c1">// Application can deal with the lack of this extension</span>
<span class="n">phys_device_selector</span><span class="p">.</span><span class="n">add_desired_extension</span><span class="p">(</span><span class="s">&quot;VK_KHR_imageless_framebuffer&quot;</span><span class="p">);</span></pre><p>Note:</p><p>Because <code>vk-bootstrap</code> does not manage creating a <code>VkSurfaceKHR</code> handle, it is explicitly passed into the <code><a href="classvkb_1_1_physical_device_selector.html" class="m-doc">vkb::<wbr />PhysicalDeviceSelector</a></code> for proper querying of surface support details. Unless the <code><a href="classvkb_1_1_instance_builder.html#a414bd96dcee186a8e77f75f0d9a4b5f1" class="m-doc">vkb::<wbr />InstanceBuilder::<wbr />set_headless()</a></code> function was called, the physical device selector will emit <code>no_surface_provided</code> error. If an application does intend to present but cannot create a <code>VkSurfaceKHR</code> handle before physical device selection, use <code>defer_surface_initialization()</code> to disable the <code>no_surface_provided</code> error.</p></section><section id="autotoc_md5"><h2><a href="#autotoc_md5">Device Creation</a></h2><p>Once a <code>VkPhysicalDevice</code> has been selected, a <code>VkDevice</code> can be created. Facilitating that is the <code><a href="classvkb_1_1_device_builder.html" class="m-doc">vkb::<wbr />DeviceBuilder</a></code>. Creation and usage follows the forms laid out by <code><a href="classvkb_1_1_instance_builder.html" class="m-doc">vkb::<wbr />InstanceBuilder</a></code>.</p><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">DeviceBuilder</span> <span class="n">device_builder</span><span class="p">{</span> <span class="n">phys_device</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">dev_ret</span> <span class="o">=</span> <span class="n">device_builder</span><span class="p">.</span><span class="n">build</span> <span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// error</span>
<span class="p">}</span>
<span class="n">vkb</span><span class="o">::</span><span class="n">Device</span> <span class="n">vkb_device</span> <span class="o">=</span> <span class="n">dev_ret</span><span class="p">.</span><span class="n">value</span><span class="p">();</span></pre><p>The features and extensions used as selection criteria in <code><a href="classvkb_1_1_physical_device_selector.html" class="m-doc">vkb::<wbr />PhysicalDeviceSelector</a></code> automatically propagate into <code><a href="classvkb_1_1_device_builder.html" class="m-doc">vkb::<wbr />DeviceBuilder</a></code>. Because of this, there is no way to enable features or extensions that were not specified during <code><a href="classvkb_1_1_physical_device_selector.html" class="m-doc">vkb::<wbr />PhysicalDeviceSelector</a></code>. This is by design as any feature or extension enabled in a device <em>must</em> have support from the <code>VkPhysicalDevice</code> it is created with.</p><p>The common method to extend Vulkan functionality in existing API calls is to use the pNext chain. This is accounted for <code>VkDevice</code> creation with the <code>add_pNext</code> member function of <code><a href="classvkb_1_1_device_builder.html" class="m-doc">vkb::<wbr />DeviceBuilder</a></code>. Note: Any structures added to the pNext chain must remain valid until <code>build()</code> is called.</p><pre class="m-code"><span class="n">VkPhysicalDeviceDescriptorIndexingFeatures</span> <span class="n">descriptor_indexing_features</span><span class="p">{};</span>

<span class="k">auto</span> <span class="n">dev_ret</span> <span class="o">=</span> <span class="n">device_builder</span><span class="p">.</span><span class="n">add_pNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_indexing_features</span><span class="p">)</span>
                             <span class="p">.</span><span class="n">build</span> <span class="p">();</span></pre><p>To destroy a <code><a href="structvkb_1_1_device.html" class="m-doc">vkb::<wbr />Device</a></code>, call <code><a href="namespacevkb.html#a9aca74e3e3da7e1b043e7d819184afc8" class="m-doc">vkb::<wbr />destroy_device()</a></code>. <code class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">destroy_device</span><span class="p">(</span><span class="n">vkb_device</span><span class="p">);</span></code></p><section id="autotoc_md6"><h3><a href="#autotoc_md6">Queues</a></h3><p>By default, <code><a href="classvkb_1_1_device_builder.html" class="m-doc">vkb::<wbr />DeviceBuilder</a></code> will enable one queue from each queue family available on the <code>VkPhysicalDevice</code>. This is done because in practice, most use cases only need a single queue from each family.</p><p>To get a <code>VkQueue</code> or the index of a <code>VkQueue</code>, use the <code>get_queue(QueueType type)</code> and <code>get_queue_index(QueueType type)</code> functions of <code><a href="structvkb_1_1_device.html" class="m-doc">vkb::<wbr />Device</a></code>. These will return the appropriate <code>VkQueue</code> or <code>uint32_t</code> if they exist and were enabled, else they will return an error.</p><pre class="m-code"><span class="k">auto</span> <span class="n">queue_ret</span> <span class="o">=</span> <span class="n">vkb_device</span><span class="p">.</span><span class="n">get_queue</span> <span class="p">(</span><span class="n">vkb</span><span class="o">::</span><span class="n">QueueType</span><span class="o">::</span><span class="n">graphics</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle error</span>
<span class="p">}</span>
<span class="n">graphics_queue</span> <span class="o">=</span> <span class="n">queue_ret</span><span class="p">.</span><span class="n">value</span> <span class="p">();</span></pre><p>Queue families represent a set of queues with similar operations, such as graphics, transfer, and compute. Because not all Vulkan hardware has queue families for each operation category, an application should be able to handle the presence or lack of certain queue families. For this reason the <code>get_dedicated_queue</code> and <code>get_dedicated_queue_index</code> functions of <code><a href="structvkb_1_1_device.html" class="m-doc">vkb::<wbr />Device</a></code> exist to allow applications to easily know if there is a queue dedicated to a particular operation, such as compute or transfer operations.</p><section id="autotoc_md7"><h4><a href="#autotoc_md7">Custom queue setup</a></h4><p>If an application wishes to have more fine grained control over their queue setup, they should create a <code>std::vector</code> of <code><a href="structvkb_1_1_custom_queue_description.html" class="m-doc">vkb::<wbr />CustomQueueDescription</a></code> which describe the index, count and a <code>std::vector&lt;float&gt;</code> of priorities. To build up such a vector, use the <code>get_queue_families</code> function in <code><a href="structvkb_1_1_physical_device.html" class="m-doc">vkb::<wbr />PhysicalDevice</a></code> to get a <code>std::vector&lt;VkQueueFamilyProperties&gt;</code></p><p>For example</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vkb</span><span class="o">::</span><span class="n">CustomQueueDescription</span><span class="o">&gt;</span> <span class="n">queue_descriptions</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">queue_families</span> <span class="o">=</span> <span class="n">phys_device</span><span class="p">.</span><span class="n">get_queue_families</span> <span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">queue_families</span><span class="p">.</span><span class="n">size</span> <span class="p">());</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_families</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queueFlags</span> <span class="o">&amp;</span> <span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Find the first queue family with graphics operations supported</span>
        <span class="n">queue_descriptions</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">vkb</span><span class="o">::</span><span class="n">CustomQueueDescription</span> <span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">queue_families</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queueCount</span><span class="p">,</span> 
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">queue_families</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queueCount</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="p">}</span></pre></section></section></section><section id="autotoc_md8"><h2><a href="#autotoc_md8">Swapchain</a></h2><p>Creating a swapchain follows the same form outlined by <code><a href="classvkb_1_1_instance_builder.html" class="m-doc">vkb::<wbr />InstanceBuilder</a></code> and <code><a href="classvkb_1_1_device_builder.html" class="m-doc">vkb::<wbr />DeviceBuilder</a></code>. Create the <code><a href="classvkb_1_1_swapchain_builder.html" class="m-doc">vkb::<wbr />SwapchainBuilder</a></code>, provide <code><a href="structvkb_1_1_device.html" class="m-doc">vkb::<wbr />Device</a></code>, call the appropriate builder functions, and call <code>build()</code>.</p><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">SwapchainBuilder</span> <span class="n">swapchain_builder</span><span class="p">{</span> <span class="n">device</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">swap_ret</span> <span class="o">=</span> <span class="n">swapchain_builder</span><span class="p">.</span><span class="n">build</span> <span class="p">();</span>
<span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">swap_ret</span><span class="p">){</span>

<span class="p">}</span>
<span class="n">vkb</span><span class="o">::</span><span class="n">swapchain</span> <span class="n">swapchain</span> <span class="o">=</span> <span class="n">swap_ret</span><span class="p">.</span><span class="n">value</span><span class="p">();</span></pre><p>By default, the swapchain will use the VK_FORMAT_B8G8R8A8_SRGB or VK_FORMAT_R8G8B8A8_SRGB image format with the color space VK_COLOR_SPACE_SRGB_NONLINEAR_KHR. The present mode will default to VK_PRESENT_MODE_MAILBOX_KHR if available and fallback to VK_PRESENT_MODE_FIFO_KHR. The image usage default flag is VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT.</p><p>Recreating the swapchain is equivalent to creating a new swapchain but providing the old swapchain as a source. Be sure to not use the same <code>VkSwapchainKHR</code> again as it expires when it is recycled after trying to create a new swapchain.</p><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">SwapchainBuilder</span> <span class="n">swapchain_builder</span><span class="p">{</span> <span class="n">device</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">swap_ret</span> <span class="o">=</span> <span class="n">swapchain_builder</span><span class="p">.</span><span class="n">set_old_swapchain</span> <span class="p">(</span><span class="n">vkb_swapchain</span><span class="p">)</span>
                                 <span class="p">.</span><span class="n">build</span> <span class="p">();</span>
<span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">swap_ret</span><span class="p">){</span>
    <span class="c1">// If it failed to create a swapchain, the old swapchain handle is invalid.</span>
    <span class="n">vkb_swapchain</span><span class="p">.</span><span class="n">swapchain</span> <span class="o">=</span> <span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Even though we recycled the previous swapchain, we need to free its resources.</span>
<span class="n">vkb</span><span class="o">::</span><span class="n">destroy_swapchain</span><span class="p">(</span><span class="n">vkb_swapchain</span><span class="p">);</span>
<span class="c1">// Get the new swapchain and place it in our variable</span>
<span class="n">vkb_swapchain</span> <span class="o">=</span> <span class="n">swap_ret</span><span class="p">.</span><span class="n">value</span><span class="p">();</span></pre><p>To destroy the swapchain, call <code><a href="namespacevkb.html#a46d215326e5cad688bab1cf01b97567e" class="m-doc">vkb::<wbr />destroy_swapchain()</a></code>. This is null out the VkSwapchainHandle inside of it.</p><pre class="m-code"><span class="n">vkb</span><span class="o">::</span><span class="n">destroy_swapchain</span><span class="p">(</span><span class="n">vkb_swapchain</span><span class="p">);</span></pre></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Illumination Engine A Game Development Engine Written In C++. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.4 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
